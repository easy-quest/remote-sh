{"version":3,"sources":["configs.js","store/router.js","store/webSocket.js","store/root.js","serviceWorker.js","index.js"],"names":["routerHistoryType","urlWebSocket","urlServer","window","location","origin","Router","history","this","subscribe","action","path","pathname","push","observable","WebSocket","callbacks","callbackBindIndex","connect","bindTest","configs","socket","io","on","connected","console","log","update","fn","type","data","filter","t","forEach","callback","socketId","id","bindEvent","RootStore","event","EventEmitter","router","webSocket","init","singleInstance","params","getSingleInstance","Boolean","hostname","match","App","React","lazy","ReactDOM","render","Suspense","fallback","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"+FAAe,KACbA,kBAAmB,OACnBC,aAAc,GACdC,UAAWC,OAAOC,SAASC,S,gHCDRC,G,qIAGRC,GAAU,IAAD,OACdC,KAAKD,UACTC,KAAKD,QAAUA,EACfC,KAAKD,QAAQE,WAAU,SAACL,EAAUM,GAChC,EAAKC,KAAOP,EAASQ,e,+BAIhBD,GACPH,KAAKD,SAAWC,KAAKD,QAAQM,KAAKF,O,uCAXnCG,c,wEAAkB,O,4BC2DNC,G,aAzDb,aAAe,yBAKfC,UAAY,GALE,KAMdC,kBAAoB,EANN,qCACZT,KAAKU,UACLV,KAAKW,W,sDAOI,IAAD,OACAlB,EAAiBmB,IAAjBnB,aACR,GAAKA,EAAL,CACA,IAAMoB,EAASC,IAAGrB,GAClBO,KAAKa,OAASA,EACdA,EAAOE,GAAG,WAAW,WACnB,EAAKC,WAAY,EACjBC,QAAQC,IAAI,2BAEdL,EAAOE,GAAG,aAAa,WACrB,EAAKC,WAAY,EACjBC,QAAQC,IAAI,0BACZ,EAAKC,YAEPN,EAAOE,GAAG,WAAW,WAAiBK,GAAQ,IAAtBC,EAAqB,EAArBA,KAAMC,EAAe,EAAfA,KAC5B,EAAKd,UACFe,QAAO,SAACC,GAAD,OAAOA,EAAEH,OAASA,KACzBI,SAAQ,SAACD,GAAD,OAAOA,EAAEE,SAASJ,MAC7BF,GAAMA,OAERP,EAAOE,GAAG,cAAc,WACtB,EAAKC,WAAY,EACjB,EAAKW,SAAW,GAChBV,QAAQC,IAAI,iC,gCAING,EAAMK,GAAW,IAAD,OACxB1B,KAAKS,mBAAqB,EAC1B,IAAMmB,EAAK5B,KAAKS,kBAChBT,KAAKQ,UAAUH,KAAK,CAClBuB,KACAP,OACAK,aAKF,OAHmB,WACjB,EAAKlB,UAAY,EAAKA,UAAUe,QAAO,SAACC,GAAD,OAAOA,EAAEI,KAAOA,Q,iCAMzD5B,KAAK6B,UAAU,QAAQ,SAACP,GACtBL,QAAQC,IAAI,kCAAmCI,U,4CA7ClDhB,c,yEAAuB,K,GCPpBwB,EACJ,aAAe,oBACb9B,KAAK+B,MAAQ,IAAIC,IACjBhC,KAAKiC,OAAS,IAAInC,EAClBE,KAAKkC,UAAY,IAAI3B,GAIzBuB,EAAUK,KAAO,WAAgB,IACvBC,EAAmBN,EAAnBM,eACR,IAAIA,EAAJ,CAF8B,2BAAXC,EAAW,yBAAXA,EAAW,gBAG9BP,EAAUM,eAAV,YAA+BN,EAAaO,KAG9CP,EAAUQ,kBAAoB,WAC5B,OAAOR,EAAUM,gBAGJN,O,8JCXKS,QACW,cAA7B5C,OAAOC,SAAS4C,UAEe,UAA7B7C,OAAOC,SAAS4C,UAEhB7C,OAAOC,SAAS4C,SAASC,MACvB,2D,MCZNX,EAAUK,OACV,IAAMO,EAAMC,IAAMC,MAAK,kBAAM,uDAE7BC,IAASC,OACP,kBAAC,IAAMC,SAAP,CAAgBC,SAAU,MACxB,kBAACN,EAAD,OAEFO,SAASC,eAAe,SDsHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAaC,gBAEdC,OAAM,SAACC,GACNzC,QAAQyC,MAAMA,EAAMC,c","file":"static/js/main.0f06287b.chunk.js","sourcesContent":["export default {\n  routerHistoryType: 'hash', // 可选 browser, hash, memory。推荐browser\n  urlWebSocket: '', // 如果设置，则会尝试连接webSocket。形如: http://your-server.com/main\n  urlServer: window.location.origin, // 服务端API地址\n};\n","import { observable } from 'mobx';\n\nexport default class Router {\n  @observable path = '/';\n\n  setHistory(history) {\n    if (this.history) return;\n    this.history = history;\n    this.history.subscribe((location, action) => {\n      this.path = location.pathname; // @action\n    });\n  }\n\n  redirect(path) {\n    this.history && this.history.push(path);\n  }\n}\n","import configs from 'src/configs';\nimport { observable } from 'mobx';\nimport io from 'socket.io-client';\n\nclass WebSocket {\n  constructor() {\n    this.connect();\n    this.bindTest();\n  }\n\n  callbacks = [];\n  callbackBindIndex = 0;\n  @observable connected = false;\n\n  connect() {\n    const { urlWebSocket } = configs;\n    if (!urlWebSocket) return;\n    const socket = io(urlWebSocket);\n    this.socket = socket;\n    socket.on('connect', () => {\n      this.connected = true;\n      console.log('Websocket connected.');\n    });\n    socket.on('reconnect', () => {\n      this.connected = true;\n      console.log('Websocket reconnected.');\n      this.update();\n    });\n    socket.on('message', ({ type, data }, fn) => {\n      this.callbacks\n        .filter((t) => t.type === type)\n        .forEach((t) => t.callback(data));\n      fn && fn();\n    });\n    socket.on('disconnect', () => {\n      this.connected = false;\n      this.socketId = '';\n      console.log('Websocket disconnected.');\n    });\n  }\n\n  bindEvent(type, callback) {\n    this.callbackBindIndex += 1;\n    const id = this.callbackBindIndex;\n    this.callbacks.push({\n      id,\n      type,\n      callback,\n    });\n    const removeBind = () => {\n      this.callbacks = this.callbacks.filter((t) => t.id !== id);\n    };\n    return removeBind;\n  }\n\n  bindTest() {\n    this.bindEvent('test', (data) => {\n      console.log('WebSocket test event recieved: ', data);\n    });\n  }\n}\n\nexport default WebSocket;\n","import EventEmitter from 'events';\n\nimport Router from './router';\nimport WebSocket from './webSocket';\n\nclass RootStore {\n  constructor() {\n    this.event = new EventEmitter();\n    this.router = new Router();\n    this.webSocket = new WebSocket();\n  }\n}\n\nRootStore.init = (...params) => {\n  const { singleInstance } = RootStore;\n  if (singleInstance) return;\n  RootStore.singleInstance = new RootStore(...params);\n};\n\nRootStore.getSingleInstance = () => {\n  return RootStore.singleInstance;\n};\n\nexport default RootStore;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport RootStore from './store/root';\n\nRootStore.init();\nconst App = React.lazy(() => import('./App'));\n\nReactDOM.render(\n  <React.Suspense fallback={null}>\n    <App />\n  </React.Suspense>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}